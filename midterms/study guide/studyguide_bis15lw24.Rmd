---
title: "studyguide_bis15lw24"
author: "Maya Ziebarth"
date: "2024-01-25"
output:
  html_document:
    theme: spacelab
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, EVAL = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(eval = FALSE)
```

### Basics 

Always load tidyverse
```{r}
library(tidyverse)
```

`?` Asks a question about the code 
```{r}
?mean
```

To make an object, use the '<-' which means 'gets' and the 'c()'
```{r}
x <- c(2, 8, 6, 6, 7, 4, 9, 9, 9, 10)
# Translation: the value x gets the numbers `2, 8, 6, 6, 7, 4, 9, 9, 9, 10`.
# you can use 'gets' to name a vector or data frame as well
y <- c(9, 4, 5)
```

Mean
```{r}
mean(x)
```

Median
```{r}
median(x)
```

DEF: A vector is an ordered list/collection of variables in a container. Itâ€™s a common way of organizing data

DEF: A data matrix is a collection of the same type of data elements (numberical, character, ect) in rows or columns.

Other basic functions include 
```{r}
8*9 #Multiplication 
8/9 #Division 
8+9 #addition 
8-9 #subtraction
```
The 5 types of 'classes' 
```{r}
my_numeric <- 42
my_integer <- 2L #adding an L automatically denotes an integer
my_character <- "universe"
my_logical <- FALSE
my_complex <- 2+4i
```

To find the 'class' you are working with, use 'class()'
```{r}
class(my_numeric)
```

To clarify or specify is a class use 'is.' and 'as.' in the beginning 
```{r}
is.integer(my_numeric)
#Translation: is the value 'my_numberic' an integer?
```

```{r}
my_integer <- as.integer(my_numeric)
#Translation: create a new object that specifies it's an interger
is.integer(my_integer)
#Translation: is my integer an integer
```

If there is any NA's or missing data that messes up your code, use
```{r}
na <- NA
is.na(na)
# or use anyNA(data)
```
If you want to get rid of any NAs, use 
```{r}
#mean(data$variable, na.rm=T) 
#use na.rm=T in the mean parenthesis
```

to find the max and min for a variable
```{r}
#max(data$variable)
```

```{r}
#min(data$variable)
```



A numeric vector looks like 
```{r}
vector <- c(10, 20, 30)
# you can make a sequence by doinc c(1:100) if you want every number between 1 and 100
```

A character vector looks like
```{r}
character <- c("monday", "tuesday", "wednesday ")
```

To find vector elements use []
```{r}
character[3]
#wednesday is the 3rd value 
```


### How to create a data.matrix
these values were given, the movie names are variables/characters and the numbers are values/numeric 
```{r}
Philosophers_Stone <- c(317.5, 657.1)
Chamber_of_Secrets <- c(261.9, 616.9)
Prisoner_of_Azkaban <- c(249.5, 547.1)
Goblet_of_Fire <- c(290.0, 606.8)
Order_of_the_Phoenix <- c(292.0, 647.8)
Half_Blood_Prince <- c(301.9, 632.4)
Deathly_Hallows_1 <- c(295.9, 664.3)
Deathly_Hallows_2 <- c(381.0, 960.5)
```

1) Start by creating a new object 
```{r}
movies <- c(Philosophers_Stone , Chamber_of_Secrets , Prisoner_of_Azkaban , Goblet_of_Fire , Order_of_the_Phoenix , Half_Blood_Prince , Deathly_Hallows_1 , Deathly_Hallows_2)
movies 
```

2) create the matrix using the code 'matrix(x, nrow=number of rows , byrow = T)
```{r}
hp_matrix <- matrix(movies, nrow=8, byrow = T) 
# The number of rows are determines by the amount of variables
hp_matrix
```

3) Name the column using the 'region <- c("name1" , "name 2" , ...)' command then use the 'colnames()' to offically name the columns
```{r}
region <- c("us", "non_us")
region
```

```{r}
colnames(hp_matrix) <- region
```

  Use the row using the 'titles <- c("variable 11" , "variable 2", ...) the the 'rownames' to officially name the rows 
```{r}
titles <- c("Philosophers_Stone", "Chamber_of_Secrets", "Prisoner_of_Azkaban", "Goblet_of_Fire", "Order_of_the_Phoenix", "Half_Blood_Prince", "Deathly_Hallows_1", "Deathly_Hallows_2")
titles
```

```{r}
rownames(hp_matrix) <- titles
```

4) Run the matrix a final time 
```{r}
hp_matrix
```


### Some ways to use a data matirx
To add all the rows together 
```{r}
rowsums <- rowSums(hp_matrix)
rowsums
```

To add a new row to the original matrix 
```{r}
hp_matrix_new <- cbind(hp_matrix, rowsums)
hp_matrix_new
```

To find the mean of a specific column 
```{r}
non_us_earnings <- hp_matrix_new[ ,2]
mean(non_us_earnings)
# cannot use '$' for this situation because the of the type of vector; when you use a c() to create the vector, it makes it atomic and not able to opperate as it's one-dimentional
```


### How to make and use data.frame
DEF: "The data frame is the most common way to organize data within R. You can think of a data frame as similar to a spreadsheet. A data frame can store data of many different classes."

Data frames vs. Data matrix 
They are differnet beause a data frame can hold numerous classes of data while a data matrix can only contain one type of class. Data frames also prename the columns, which makes your jobs easier. They also look different

1) Start by running the vectors 
```{r}
sex <- c("girl", "boy", "girl")
length <- c(19.8 , 20.34 , 18.4)
weight <- c(7.4 , 8.7 , 6.9)
```

2) Combine the vectors to make a dataframe with teh command data.frame
```{r}
newborns <- data.frame(sex, length, weight)
newborns
```

If you want to access a data point use
```{r}
newborns[ ,3]
# this is the same as a data matrix
```

To add rows, first run the new variables, then use 'rbind' 
```{r}
baby4 <- c("boy" , 23.05 , 9.1)
baby4
```

```{r}
newborns <- rbind(newborns, baby4)
newborns 
```
To add columns, use the '$' 
```{r}
newborns$eye_color <- c("brown" , "brown" , "blue" , "brown")
newborns
```


### .CSV
To write and save data as a .csv file, use
```{r}
write.csv(newborns, "newborns_data.csv", row.names = FALSE)
```

To import a .csv file, use
```{r}
newborns <- read_csv("newborns_data.csv")
#Make sure your in teh right directory i.e. correct lab and correct data file
#Usually there will be a "data/..." before because the data will be given
```

### Summary Fuctions 

These are basic functions that show specific information of the data

summarizes data
```{r}
summary(newborns)
```

same as summary but shorter 
```{r}
glimpse(newborns)
```

Use str() to show the structure of the data frame and its individual columns
```{r}
str(newborns)
```

the numbers of rows.
```{r}
nrow(newborns)
```

the number of columns.
```{r}
ncol(newborns)
```

the dimensions.
```{r}
dim(newborns)
```

the class
```{r}
class(newborns)
```

the column names.
```{r}
names(newborns)
```

'heads()' shows the first n rows of the data frame.
```{r}
head(newborns) 
#works better with large amounts of data
```

'tails()' shows the last n rows of the data frame.
```{r}
tail(newborns) 
#works better with large amounts of data
```

'table()'is useful when you have a limited number of categorical variables
```{r, EVAL = TRUE}
table(newborns$eye_color) 
```

```{r}
newborns <- as.factor(newborns$sex)
```

### TO CHANGE CLASS TO FACTOR 
```{r}
#class_t <- as.factor(homerange$taxon)
#use for few data point otherwise use the mutate version
```

Display levels
```{r}
#levels(class_t)
```



### Extracting data

DEF: dplyr: "dplyr is used to transform data frames by extracting, rearranging, and summarizing data such that they are focused on a question of interest"

### Select: 
Allows you to pull out columns of interest. It works best with large data sets as it's hard to see values. 

The basic command is 'select(data, "name", "name", ...)'
```{r}
select(newborns, "length" , "weight")
```

if you want to grab numerous sections us a ':'
```{r}
select(newborns, "sex":"weight")
```

if you want to keep sections and not some, use '-'
```{r}
select(newborns, -"length")
```

contains 
```{r}
select(newborns, contains("l"))
```


starts with
```{r}
select(newborns, starts_with("eye"))
```

ends with 
```{r}
select(newborns, ends_with("th"))
```

if you want to pull a certain class
```{r}
select_if(newborns, is.numeric)
```



### Filter: 
Allows you to pull out certain values of interest. while select us used to pull columns, filter us used to pull specific data within a column. 

if you want the data to equal a value use '=='
```{r}
filter(newborns, sex=="boy")
#remember filter alwasy uses == not =
```

if you want a certain numerical value greater or lesser than a certain point use '>= and <='
```{r}
filter(newborns, length <= 20)
```

if you want a everything but a value use '!=' (not equal)
```{r}
filter(newborns, eye_color != "blue")
```

if you want something between certain points is '%in%'
```{r}
filter(newborns, length %in% c(19.8, 20.34))
#this mean includes, the values you input have to be a value in the table otherwise it wont run
```
if you want something near an value 
```{r}
filter(newborns, near(weight, 7, tol = .5))
# not used often in class, tol mean how close to the number you want to be 
```
if you want something '&'
```{r}
filter(newborns, sex=="boy" & length >= 21)
```


if you want something or soemthing else '|'. This only works if they variables can't be true at the same time.
```{r}
filter(newborns, eye_color=="brown" | weight <= 8)
```



### Pipes

```{r}
library(janitor)
fish <- read_csv("Gaeta_etal_CLC_data.csv")%>% 
  clean_names()
```
Another and factor way to clean names, make sure janitor is already installed
```{r}
fish <- janitor::clean_names(fish)
```


Use these when you want to combine specified data (shift+command+m)
```{r}
newborns %>% 
  select("sex", "weight") %>% 
  filter(weight >= 7 & sex != "boy")
```

The arrange function allows you to sort the funtion, just arrange is low to high, use arrange(desc()) to arrange lower to higher
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(scalelength)
```

```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(desc(scalelength))
```

### Mutate

Mutate allows us to create a new column from existing columns in a data frame.

Convert the length variable and create a new variable called length_tenx. 
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
#this creates a new column with affected data of a preexisting data. 
```
another way to use mutate is to change all CHARACTERS TO FACTORS
```{r}
fish %>%
  mutate_if(is.character, factor)
#this changes a character to a factor, when multiple characters
```
OR for individual cases 
```{r}
#fisheries$country <- as.factor(fisheries$country) %>% 
  #fisheries$isscaap_group_number <- as.factor(fisheries$isscaap_group_number)
  #fisheries$asfis_species_number <- as.factor(fisheries$asfis_species_number)
  #fisheries$fao_major_fishing_area <- as.factor(fisheries$fao_major_fishing_area)
```

This changes all values within the dataset to lowercase letters
```{r}
fish%>%
  mutate_all(tolower)
```

```{r, echo=FALSE}
mammals <- read_csv("mammal_lifehistories_v2.csv", na = c("-999.00")) %>% # the na=c("") converts evrything to na when loading in in case
  clean_names()
```

Use the 'if_else' function to make the any nonvalue (-999, NA, ect) into Nan which mean not a number which you can us to tabulate means and such easier
```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>%
  arrange(newborn)
```

Tabyl is like table but more in depth 
```{r}
tabyl(fish, lakeid)
```

### Summarize

load package skimr
```{r}
library(skimr)
```

Like summary but cleaner
```{r}
skim(fish)
```

To make a histogram
```{r}
hist(mammals$litters_year)
```
summarize makes things cleaner, use it for mean, max, min and sd of filtered variables.
```{r, echo=TRUE}
fish %>% 
  filter(scalelength<=3) %>% 
  summarize(mean_mass=mean(length),
            max_mass=max(length),
            min_mass=min(length),
            sd_mean=sd(length),
            total=n()) #total=n() shows the total number of objects used 
```
if you want to find the number of distinct observations, sometimes there are repeated values
```{r}
mammals %>% 
  filter(mass > 100) %>% 
  summarize(n_genera=n_distinct(genus)) #n_genera is the name 
```

### group_by
group_by is used with summary, groups by categorical variables 
```{r}
#ASK ABOUT THIS
mammals %>% 
  group_by(order) %>% 
  mutate(mass_new = ifelse(mass == -999.00, NA, mass))%>% 
  summarize(mean_mass=mean(mass_new),
            max_mass=max(mass_new),
            min_mass=min(mass_new),
            sd_mass=sd(mass_new),
            #sum_mass=sum(mass_new), just as an exapmle of how to use sum.
            total=n())
```

### counts 
Tells you how many observations in each column (you can also use tabyl for). Does the same thing as group_by + summarize
```{r}
fish %>% 
  count(lakeid, sort = T) #sort=T sorts the column in descending order
```

### across
A cleaner version of finding the distinct number of observations, mean, max, ect.  across multiple groups with summarize
```{r}
mammals %>%
  summarize(across(c(species, order, family, gestation), n_distinct))
```
You can use commands such as 'contains' which asks if a variable contains that input to use them
```{r}
mammals %>% 
  group_by(genus) %>% 
  mutate(litter_size_new = ifelse(litter_size == -999.00, NA, litter_size))%>% #you have to do this for each line 
  mutate(litters_year_new = ifelse(litters_year == -999.00, NA, litters_year))%>% 
  summarize(across(contains("_new"), mean, na.rm=T)) 
                   #\(x) mean(x, na.rm = TRUE))) #use this to correct the error, not always necessary
```
Or to pull out specific characters 
```{r}
mammals %>% 
  summarize(across(where(is.numeric), mean, na.rm=T)) %>% 
  select(!weaning) #excluding the numeric variable weaning
```

### USE HW5 AND MIDTERM ANSWERKEY FOR BIG REFFERENCES
### THINK CRITICALY ABOUT THE QUESTIONS BEFORE JUMPING IN, YOU COULD MISS SOMETHING IMPORTANT


###  More about NAs

load the library, this allows you to pull and change data with irregular NAs
```{r}
library("naniar")
```

'miss_var_summary' gives the number of missing variables only when the variable says "NA"
```{r}
miss_var_summary(mammals)
```

reload the data and input na=c() to covert these variables into NAs
```{r}
mammals <- read_csv("mammal_lifehistories_v2.csv", na = c("-999.00", "-999"))
```

OR you can use this command with a pipe and rerun the missing vraible
```{r}
mammals_tidy <- mammals %>% 
  replace_with_na_all(condition = ~.x == -999.00) 
miss_var_summary(mammals_tidy)
```
if each column has a different variable input for na use
```{r}
#life_history %>%
 # replace_with_na(replace = list(newborn = "not measured", 
                               #  weaning= -999, 
                               #  wean_mass= -999, 
                              #    afr= -999, 
                              #   max_life= 0, 
                               #  litter_size= -999, 
                                # gestation= -999, 
                               #  mass= -999)) 
```


### Pivoting
```{r}
heartrate <- read_csv("data/heartrate.csv")
billboard <- read_csv("data/billboard.csv")
gene_exp <- read_csv("data/gene_exp.csv")
heartrate2 <- read_csv("data/heartrate2.csv")
tb_data <- read_csv("data/tb_data.csv")
```


pivot_longer is used when the data is in a column and should be elongated and placed into one column 
```{r}
heartrate %>% 
  pivot_longer(-patient, #patient will not move
               names_to = "drug", #make a new column called "drug"
               values_to="heartrate",#values moved to a new column called
               values_drop_na = TRUE) #this will drop the NA's
```
```{r}
billboard %>% 
   pivot_longer(
   cols = starts_with("wk"), #columns that start with "wk"
   names_to = "week",
  names_prefix = "wk",
   values_to = "rank",
  values_drop_na = TRUE)
```


pivot_wider is used when the data in one column but should be it's own columns with the values form something else 
```{r}
tb_data %>% 
  pivot_wider(names_from = "key", #the observations under key will become new columns
              values_from = "value") #the values under value will be moved to the new columns
```

if you want to separate a column name with compounded data, use 'separate' 
```{r}
heartrate3 <- heartrate2 %>% 
  separate(patient, into=c("patient", "sex"), sep="_") %>% 
  pivot_longer(-c(patient, sex),
               names_to = "drug",
               values_to = "heartrate")
```


### Specifications
'slice_max' condenses repeating variables like n_distinct but gives the values not a single number. Goes after arrange
```{r}
mammals %>% 
  group_by(family) %>% 
  summarize(mean_newborn=mean(newborn)) %>% 
  arrange(desc(mean_newborn)) %>% 
  slice_max(mean_newborn, n=5)
```
'top_n' gives the top value gives the to number based on a character value from a select of 2, best with plots
```{r}
mammals%>% 
  select(species, mass) %>% 
  top_n(-15, mass)
```



### Plots 

to make a plot start by piping into 'ggplot()', wrapping in 'aes' and use '+' to add a layer, then use 'goem_plottype()', depending on the plot you want. 

eliminates the use of scientific notation
```{r}
homerange <- read_csv("data_full/Tamburelloetal_HomeRangeDatabase.csv")
options(scipen=999) #cancels the use of scientific notation for the session
```


Scatterplot
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra))+
  geom_point()
```

to avoid extraneous data use goem_jitter, which is teh same as scatter but more precise in large data sets
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra))+
  geom_jitter(na.rm=T)
```

to add a best fit line is 'geom_smooth'
```{r}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra))+
  geom_jitter(na.rm=T)+
  geom_smooth(method=lm, se=F) #se=F says that standard error is not shown.
```


Boxplot
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=order, y=log10.hra))+
  geom_boxplot()+
  coord_flip() # flips the x and y to make it look cleaner
```


Bar Plots: only need x axis, it automatically shows count
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=order))+
  geom_bar()
```

Columns: used whne you use 'count' first
```{r, EVAL = TRUE}
homerange %>% 
  count(order, sort=T) %>% 
  ggplot(aes(x=order, y=n))+
  geom_col()
```

Histogram
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x = log10.mass)) +
  geom_histogram(bins = 20)+ #we can adjust the number of bins with the bins argument
  labs(title = "Distribution of Body Mass")
```

Desnity plots
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x = log10.mass)) +
  geom_density()
```

Histogram and Desnity 
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass)) +
  geom_histogram(aes(y = after_stat(density)))+
  geom_density()
```


Faceting: creates multiple graphs for differnt groups
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass))+
  geom_density(fill="steelblue", color="black", alpha=0.6, na.rm=T)+
  facet_wrap(~taxon)
```
onother exapmle of wrap
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=taxon, y=log10.mass))+
  geom_boxplot()+
  facet_wrap(~trophic.guild)+
  theme(axis.text.x = element_text(angle = 60, hjust=1))
```

you can use facet_grid for more specificity, rows~columns
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=taxon, y=log10.mass))+
  geom_boxplot()+
  facet_grid(trophic.guild~thermoregulation)+
  theme(axis.text.x = element_text(angle = 60, hjust=1))
```


### Fun with Graphs 
to add color use fill for bars and col, color for scatter and jitter. Fill with a character variable 
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=order, fill=primarymethod))+
  geom_bar(position = "dodge", na.rm=T) #moves the stacks to side by side
```

```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra, color=primarymethod))+
  geom_jitter(na.rm=T)
```

titles and looks

'labs()' is the command which labels the title & x and y axis
```{r, EVAL = TRUE}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra))+
  geom_jitter(na.rm=T) +
 labs(title="Homerange Mass vs HRA", #adds a title
       x="Mass",
       y="HRA")+
  theme(plot.title=element_text(size=rel(1.75), hjust = 0.5)) # rel is title size relative ot the graph, hjust is the title position (center)
```
'theme_-----()' will make teh graph have a tidy look. I like classic or light, they are the cleanist
```{r}
homerange %>% 
  ggplot(aes(x=log10.mass, y=log10.hra, color=primarymethod))+
  geom_jitter(na.rm=T)+
  theme_classic()
```



scale_x_discrete orders the variables on the x axis when they're character variables. 
```{r, EVAL = TRUE}
homerange %>% 
  count(taxon) %>% 
  ggplot(aes(x=taxon, y=n))+
  geom_col(alpha=0.8, fill="lightblue", color="black", na.rm=T) +
 labs(title="Number of Observations per Taxon",
       x="Taxon Name",
       y="# of Observations")+
  theme(plot.title=element_text(size=rel(1.75), hjust = 0.5)) +
  scale_x_discrete(limits=c("mammals", "birds", "marine fishes", "snakes", "turtles", "river fishes", "tortoises", "lizards", "lake fishes")) +
  theme_classic()
```

Color pallets 
```{r}
library(RColorBrewer)
library(paletteer)
library(ggthemes)
```

use scale_fill_brewer (for fills) and scale_colour_brewer (for points) for more palettes respecitvly. 
```{r, EVAL = TRUE}
homerange %>%
  ggplot(aes(x=taxon, fill=trophic.guild))+
  geom_bar(na.rm=T, position="dodge") +
  scale_fill_brewer(palette = "PuBuGn")+
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 60, hjust=1))+
  labs(title = "Observations by Taxon in Homerange Data",
       x = NULL,
       y= "n",
       fill= "Trophic Guild")
```
you can make a frame called 'my_palette' to store a preselected color palette. you have to have a pallete that has enough colors for your variables 
```{r}
colors <- paletteer::palettes_d_names #shows palettes
my_palette <- paletteer_d("ggsci::nrc_npg") #store your palette,
```


```{r, EVAL = TRUE}
homerange %>%
  ggplot(aes(x=taxon, fill=trophic.guild))+
  geom_bar(na.rm=T, position="dodge") +
  scale_fill_manual(values=my_palette)+
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 60, hjust=1))+
  labs(title = "Observations by Taxon in Homerange Data",
       x = NULL,
       y= "n",
       fill= "Trophic Guild")
```


### ALWAYS ADD FUN THINGS LIKE TITLES AND COLORS TO GRAPHS IN TESTS




